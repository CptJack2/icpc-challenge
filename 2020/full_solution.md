#ICPC World Final 2020完全题解
最近刚好赋闲在家，花了一个月的时间刷完了WF2020的题目，今年的题目质量也很高，不少题涉及到了计算几何和数论的知识，做起来挺有趣的。

#A Cardiology
一个魔术大师变卡牌魔术，摆出一个r行c列的牌阵，牌的序号按照先从左到右，然后从上到下递增。他会让你选定一张牌，然后让你指出那张牌所在的那一列，接着他会一列一列的收牌，收牌时保证指出的列第p位被收走，收完后再按行顺序摆牌，再让你指出指定牌在哪一列，再次按列收牌，按行摆拍，重复若干次，你指定的牌就会出现在牌阵的中心。

这里面没有什么魔法，就是个数字游戏，你指定的牌在牌阵中的可能位置的范围会随着他不断的收牌发牌操作不断收缩，最后到达一个稳定的位置，游戏就结束了。用题目的例子，一开始你的牌可能的位置范围是1-21号，可能在的行是1-7；第一次收牌后，可能位置变成了8-14（第二列被收走后重新按行排），这时候牌只能在3-5行；第二次收牌后，可能位置变成10-12（8号开始数的第3-5个），可能行只能是4；第三次后，可能位置只有11（4行2列），恰好是牌阵中心。
解法也很简单，取1-c之间的每一个可能的p值，模拟他这个收牌发牌的过程，算出这个p下最后稳定的位置（也可能p值会收缩到一个范围，而不是单一位置，这时候直接跳过这个p），最后比较一下哪个p迭代最少且最靠近中心就可以了。

#B The Cost of Speed Limits
有一个树形的小镇，每个街区用节点表示，街区之间用无向的边作为街道连接。每条边有各自的限速，对于每个节点，如果节点上的各边限速不同，需要进行改造：要么将所有的边的限速提高至同一标准，要么在每条边的路口处设置限速标志。每条边提高1km/h速度成本是1，每个限速标志成本是c。现在要求找出对图中每个节点完成改造，最低的成本。

对于每个节点，只有两种改造方法，要么在所有路口放置限速标志，要么将这个节点所有边的速度都提到同一水平，来避免放置限速标志。由于对单个节点调整速度的时候，只会调整到当前节点边的最大速度或者更高，所以对整个图调整速度的时候，只需要考虑调整为初始时图中边的速度。读入数据的时候就可以对图中不同的速度从小到大排序，作为调整的备选，而不用考虑全体整数。
然后在树上进行动态规划求解，用深度优先的方式遍历树，每趟递归过程处理以当前节点为根的子树，包括从当前节点的父节点进入到当前节点的那条边。递归函数返回值是pair<int, vector<int>>，代表当前子树的最小花费，和当前子树调整到不同速度的花费。
求解当前子树的最小花费的时候，先求解树立限速标志的花费，它等于当前节点的度乘以c，加上所有子树的最优花费。然后求当前子树调整到不同速度的花费，由于不允许降速，对于小于当前节点最大速度的速度，调整花费置为放置标志的花费；对于大于等于最大速度的，调整费用等于当前节点的各个子树调整到对应速度的花费的和（通过深度优先已经求出来了。前面说小于当前节点最大速度的调整花费也要求，是因为父节点可能会尝试调整到这些速度），加上进入节点的路径的调整花费，然后还要与树立标志的花费比较（不要忘了进入路径的调整），看看哪个更优。最后，将树立标志的费用和调整到各速度的费用进行比较，得出的最优即是这个子树的最佳花费。
现在说明一下为什么这样动归是合理的。对于放置标志的方案，由于当前节点的花费不受子树速度变更的影响，所以各子树可以选用自己最佳的方案，从而达到整体最优。变更速度的方案则更加简明，为各个子树变更到对应速度的花费之和。由于只可能有这两种改造方案，两种方案中的最优肯定是全局最优。

#C Domes
在一个矩形的广场上有若干个点，代表圆塔。游客需要对这些圆塔进行拍照，使得照片上的圆塔按照指定的顺序出现。现在给定一个指定的圆塔顺序，假设相机的拍摄角度为180°，问广场上能够拍出符合要求的照片的区域有多大。

这是一条计算几何的问题，对于两个点v1、v2，要使得照片上v1出现在v2左边，拍摄区域只能在向量v1v2的右边。初始时将可行区域设为广场所在的矩形，对于排列中每一对点，求出通过它们的直线，再求直线和可行区域的交点，更新可行区域。由于可行区域永远只在直线的一侧，所以这是个凸多边形。
对于判断点v3在v1v2的哪一侧，采用算叉积的办法，如果v1v2xv1v3 < 0，则v3在v1v2右侧；等于0则v3在v1v2的直线上；大于0就是在左侧。遍历可行区域的每一线段，来求它和直线的交点，判断有无交点可以通过线段两点对直线的叉积是否异号，来判断线段是否跨过了直线。最后求可行区域的面积，直接用前面求得的多边形的顶点轨迹，所有相邻两点求叉积，把所有叉积求和再除2，然后求绝对值即是多边形的面积，这个方法对凸多边形和凹多边形求面积都适用。
这题的求解不会涉及到精度和epsilon的问题，所有浮点数直接用double存储即可。
假如问题扩展一下，相机的拍摄角度不是180°，而是θ<180°，那么可行区域其实也是类似的，是直线分割的半边区域，但还要挖去一小部分，注意到圆弧上的任意一点和圆弧的两端的连线所形成的夹角是恒等的，其实这挖去的一小部分就是一段圆弧围成的区域。

#D Gene Folding
有一个只包含ATGC四种字符的字符串代表的基因，如果它的头或者尾是一个回文串的话，那么可以把回文串对称的一半去掉，只留下另一半。问这样操作若干次之后，字符串最短的长度是多少。

题目的描述有问题：
For instance, in the sequence ATTACC, there are two such points: AT-TACC and ATTAC-C. Then pick one of these points (say, the first one), and fold the genetic sequence at that point, merging the identical nucleotides (so, in this case the AT and TA would become merged, and the resulting sequence would be CCAT or TACC).
这里ATTACC不能把头部拼到尾部变换成CCAT，不然就跟解法不一样了。
解法不复杂，对Manacher算法进行一些修改就行了（一种能在O(N)复杂度内找出字符串中所有回文子串的算法，可自行搜索）。用两个下标head和tail记录答案字符串的起止位置，Manacher算法找出回文子串的过程中更新head，完成算法后，再从尾部根据回文串的位置更新tail，然后输出答案。

#E Landscape Generator
有一个游戏要通过Raise、Depress、Hill、Valley四种规则生成模拟的地形。开始时整个正整数轴的海拔都是0。Raise和Depress把一段区间的海拔+1/-1。Hill/Valley把一段区间修改为山峰/山谷，顶/底在区间中点。给定一系列的操作，要你输出生成的地形。

这题很简单了，因为都是区间操作，用差分数列去存储实际的海拔，以便进行区间修改。同时，因为还有Hill和Valley的操作，记mid=(start+end)/2，两个操作相当于把区间[start,end]的海拔先+1/-1，然后对[start,mid]的斜率+1/-1，对[mid+1,end]的斜率-1/+1（end-start为奇数的情形，为偶数有些微不同，mid处斜率直接反转）。Hill和Valley也是区间操作，所以用另外一个差分数列存储坐标下的斜率。
完成所有操作得到两个差分序列后，先从斜率差分数列还原出山谷和山峰，然后通过海拔差分数列还原海拔，就得到了结果。

#F Ley Lines
一张地图上标了n个坐标点，现在给你一支笔头直径是t的笔，让你在地图上画一条直线，问最多能覆盖多少个点。

相当于在二维空间里有一系列坐标点，要画两条平行的直线，两条直线间的距离是t，要求覆盖尽可能多的点。首先如果两条直线没有穿过任何点，总可以将它们上下平移，直至触碰到其中一个点，这时候两条直线覆盖到的点数保持不变。有了这个变换前提，就可以从每个点画一条平行于x轴的直线，然后在它下方距离t画另外一条平行直线，将这两条线旋转360°，看看能覆盖多少个点。对n个点都这么操作一遍后，能覆盖到最多的点数就是答案。
我的实现上，首先选定一个点，对每个其他的点，求出它们之间直线的夹角θ（通过arctan），然后求下方距离t的直线通过这个点时的夹角φ。在两条直线水平夹角处于区间[θ,θ+φ]和[θ+π-φ,θ+π]（两条直线旋转超过180°，下方的直线跑到上方，从另外一边覆盖到这个点）时，这个点就处于两条直线间的区域之中。求出所有n-1个点的θ和φ后，对它们排序。为了避免在初始状态时又进行一次O(N-1)的操作判断哪些点在区域内，直接将角度转过两圈720°，最后就得出了通过当前点能覆盖的最多点数。对n个点都进行上述操作后，就可以得到答案。
这一题也不涉及精度和epsilon的操作，直接用double存储角度，调用C库的arctan和arcsin求角度即可。整个算法复杂度为O(N^2)。

#G Opportunity Cost
有n个手机，每个手机有xyz三种属性，只能选择其中一只手机，所以选择会伴随着机会成本，两个手机的机会成本定义为max(xi−x,0)+max(yi−y,0)+max(zi−z,0)。要求从n只手机中选择一只，使得它对其他手机的最大机会成本（max1≤i≤n(max(xi−x,0)+max(yi−y,0)+max(zi−z,0))）最小。

暴力搜索的方法复杂度是O(N^2)，但是可以通过对带max函数的成本公式做一些简单的变换，使得复杂度下降为O(N)。
首先注意到，对于选定手机(x,y,z)和任意一只手机未选定手机(xi,yi,zi)，成本公式为max(xi-x,0)+max(yi-y,0)+max(zi-z,0)。这个等式等价于max(0, xi-x, yi-y, zi-z, xi+yi-x-y, xi+zi-x-z, yi+zi-y-z, xi+yi+zi-x-y-z)，即xyz每一个维度均有计算和不计算两种选择，排列组合一共八种情况，里面的最大值就是机会成本。
一个手机对另外n-1个的机会成本，又等于单个机会成本的最大，进行一下公式变换：
max(1<=i<=n)(max(xi-x,0)+max(yi-y,0)+max(zi-z,0)) =
max(
    0,
	max(1<=i<=n)(xi-x),
	max(1<=i<=n)(yi-y),
	max(1<=i<=n)(zi-z),
	max(1<=i<=n)(xi+yi-x-y),
	max(1<=i<=n)(xi+zi-x-z),
	max(1<=i<=n)(yi+zi-y-z),
	max(1<=i<=n)(xi+yi+zi-x-y-z)
)
=max(
    0,
	max(1<=i<=n)(xi)-x,
	max(1<=i<=n)(yi)-y,
	max(1<=i<=n)(zi)-z,
	max(1<=i<=n)(xi+yi)-x-y,
	max(1<=i<=n)(xi+zi)-x-z,
	max(1<=i<=n)(yi+zi)-y-z,
	max(1<=i<=n)(xi+yi+zi)-x-y-z
 )
所以只需在一次O(N)的遍历中，求出7个维度的最大值，和每只手机对应维度属性的和，最后再通过一遍O(N)的遍历，就可以求出每只手机被选择的机会成本，取当中最小的为答案即可。

#H QC QC
有一批QC机器，不知道好坏，但它们能够分辨其他机器的好坏，每一轮中，每台机器可以检测一台其他的机器，自己同时也可以被其他机器检测。（有点无间道那味了）如果机器是好的，那么它会给出被检测机器的正确结果；如果机器是坏的，它会给出任意结果，但保证对同一台被检机，每次结果都一样。同时，已知超过半数的机器都是好的。现在要求在12轮检测中，分辨出所有机器的好坏。

这题除了背景比较有趣外，它的IO是交互式的，你需要自己指定在一轮检测中，哪台机器检测哪台，并且读回检测结果，最后输出答案。
首先定义一个叫component的概念，它其实就是一个机器的集合，集合中的所有机器要么都是好的，要么都是坏的。然后将这些component分为三类：active、paired、leftover。起始时，每个机器独自成为一个component，归入到active类中。
首先解析一下互相两台机器互相查询对方的结果，如果返回的结果都是好的，那么这两台机器要么都是好的，要么都是坏的，也就是状态一致；如果一台说对方好，另外一台说对方坏，那么说对方好的一定是坏的，说对方坏的未知；如果两台都说对方是坏的，那么两台都是坏的，要么其中一台坏了，反正不可能两台都是好的。也就是说，后面两种情况中，两台机器最多只有一台是好的。

题目的算法分为三个阶段，第一阶段，不断将active中的每两个component取出，两个component各出一台机器，让它们互相查询对方。根据返回的结果，如果两台都说对方是好的，由于各自的component中机器状态一致，两台机器状态也一致，那么两个component中的机器状态也一致，将两个component合并为一个，继续放入active类中。如果两台机器说法不一致或者都说对方坏了，那么这两个component中，最多只有一个中的机器是好的，将它们组成一对，放入paired类中。
如果这一轮中，active中的component为奇数个，剩下的一个component拿来和leftover中的每一个component互相查询，设现在是第K次查询，那么active里面的component大小是2^(K-1)，leftover中最多有K-1个component，所以剩下的这一个component中的机器数量必然可以覆盖完leftover中的所有component。如果查询结果表示leftover中的component和active中剩下的这个component状态一致，那么将leftover中的component合并到active中剩下的这个component，最后把剩下的这个component又放到leftover中。
第一阶段一直重复上面的过程，直到active中的component只剩下0或1个为止。

然后进入到第二阶段，由于在所有的机器中，超过一半都是好的，而这时候paired中的component都是成对的，且最多只有一半是好的，那么可以推断出，paired之外剩下的机器（active+leftover）必然有超过一半是好的，否则就不能满足全体中超过一半是好的这个条件。
这时候active中有0或1个component，如果active中没有component的话，那么leftover中最大的component中的机器一定是好的（因为好的会不断把其他leftover中好的component合并到一起，所以最大的这个必然超过leftover中的机器数的一半），并且其他的component中的机器都是坏的（假如它们是好的，阶段一的过程中它们就会被最大的component合并了）。
如果active中剩下一个component的话，那么这个component中的机器是好的（假设阶段一进行了K轮查询，这个component的大小就是2^(K+1)，而leftover中最多有Σ(i=1→K)2^i=2^(K+1)-1个机器，所以剩下的component中机器数必然超过active+leftover的一半），用一轮查询利用它去查询leftover中的每个机器，分辨它们的好坏。

接下来到第三阶段，这时直接用好的机器去检测paired中的每一个component，就可以知道剩下的机器的好坏了。这里有个节省查询次数的技巧，如果第三阶段开始时，好的机器数为G，坏的机器数为B，并且G<=B+2*min(paired中的component的大小)，那么可以推测出，paired中的每一对component必然是一个好，一个坏，否则坏的数目就会超过好的。

关于查询轮数不会超过12的分析，可以看一下代码附的ICPC Judge Onufry的分析的最后部分。

#I Quests
有一系列的任务，每一个任务完成后有指定的分数奖励，每达到一定分数就会晋升等级，同时每个任务还有一个等级限制，如果在达到限制等级前完成任务，就能获得额外的分数奖励，要求找出一个完成任务的顺序，使得取得的分数最大。

完成任务应该遵循三条原则:
1.应该先做能拿到bonus的quest,后做拿不到bonus的,即最后完成任务的序列,前半部分是有bonus quest,后本部分是无bonus quest。假设在前面做了一个无bonus quest q1,后面做了一个有bonus q2. q1 q2交换顺序,q1仍无bonus;q2因为提前了,肯定还有bonus,所以不影响总分。对一个能得到最大得分的任务序列中每一对这样的q1q2同样操作,总能得到一个前半部分是有bonus quest,后本部分是无bonus quest的序列。所以求最大得分序列的时候可以遵循这条原则。
2.无bonus的quest,完成的顺序不影响：因为无论怎么样都是拿基础分。
3.设完成这个任务后最大可能达到的分数maxScore(i)=c*xi+v*di-1,maxScore小的quest应该先做：根据原则1,如果有一个能赶上maxScore,另一个不能,能赶上的应该排前面；根据原则2,如果q1q2都不能在maxScore内完成,讨论它们的顺序无意义。那么设q1q2顺序相邻且都能拿到bonus,设mS1>mS2，有一个隐含推断,设当前分数为sco, sco+c*x<maxScore=c*x+v*d-1 等价于 sco<v*d-1, 即获得bonus完成任务的情况下,分数小于maxScore,则当前分数肯定小于任务的等级限制。将q2提前,q2肯定还能拿到bonus; q1放后,因为q1q2做完总分<=mS2<mS1,所以q2q1做完的总分不变,还是小于mS1,所以根据上面的隐含推断,变换后的顺序仍合法。同样可以像原则1中的操作方式,得到一个最大得分任务序列满足原则3。

根据上面的推断，可以先计算出各个任务的maxScore，然后按照任务的maxScore小到大对任务排序。接着用动态规划的方式，求得可以获得bonus的任务的总分（其实就是01背包的动归）。称能得到bonus的任务的集合为bonus集合，通过动态规划的方法尝试将不同的任务加入bonus集合，用一个下标为bonus集合总分的dp数组，表示对应的总分能否取得，初始设dp[0]=true，其他为false。从头遍历前面排好序的任务，考虑前面任务能达到的总分，和任务的等级限制的分数，从后往前遍历，前面的任务能取得的总分加上当前任务的分数，即是加入当前任务后能获得的总分。最后选出dp数组中为true的最大下标，即是bonus集合最大的得分。求得bonus集合后，再加上任务的基础得分，就可以得到答案。

#L 'S No Problem
有一个树状的教学楼地图，每个节点是一个教学楼，边是连接教学楼的路，现在有两台扫雪机，每一台扫雪机都可以从任意节点出发，经由边出发到另一节点，也可以沿着走过的边反方向走回来，最后也可以停在任意节点。现在要求每条边都被扫过至少一次，要求两台扫雪机扫过的最短路径长度。

可以每条边一进一出两次，形成一个包裹整棵树的大环，从任意节点出发，可以沿着树走一圈回到这个节点。接下来，在树里找两条没有公关边的路径，从环中去除这两条路径，就可以得到两台扫雪机的行进路径（两台机器分别从去除的路径的开始节点出发，去除路径的结束节点为终点），之所以去除的路径不能有公共边，是因为如果有公共边，这条边就没有被扫雪机清扫了。也就是说只要两条去除的路径最长，那么扫雪机的行走距离就会最短，因为它们的和总是所有边长的两倍。接下来，问题就变成从树中找两条不相交的路径，并使得它们的长度和最长。如果问题扩展开来，不是2台扫雪机而是k台，就等价于从环里挖去k条不相交的路径。
找出树中最长的两条不相交的路径，使用的是在树上进行动态规划的方法，跟找出树上最长的一条路径是相似的。用深度优先搜索先处理子树，每个子树返回以下四个结果：1.从根出发，最长的路径。2.子树中的最长路径。3.长度之和最长的两条路径，其中一条从根出发。4.长度之和最长的两条路径。当当前节点所有子树的四个结果都被计算出来，就可以利用子树的四个结果计算当前节点的四个结果。值得一提的是ICPC judge bruce merry的这份代码（bmerry2.cpp）：
```c++
static vector<int> recurse(vector<node> &nodes, int cur, int parent, int E) {
    node &n = nodes[cur];
    vector<int> dp(E + 1, 0);//dp[0]永远等于0.dp[1]为cur到任意叶子的最长高度.dp[2]为子树中最长路径
    for (const auto &ch : n.edges) {
		if (ch.dest == parent) continue;
		auto sub = recurse(nodes, ch.dest, cur, E);
		for (int i = E-1; i >= 0; i--)
			for (int j = E - i; j >= 1; j--) {
				int score = dp[i] + sub[j] + ((j & 1) ? ch.len : 0);
				dp[i + j] = max(dp[i + j], score);
			}
	}
    return dp;
}
```
只要传入E=2*K，就可以求出树中的任意K条总和最长的路径长度，巧妙的地方在于它的dp数组的更新方式。

#K Space Walls
有一个由立方体组成的空间站，有若干个清扫机器人，在t=0时从某一个立方体表面出发，沿着指定方向前进打扫空间站表面，如果到了边缘，它会翻转90°贴着空间站表面继续前进，现在需要求出这些机器人会否碰撞到一起，如果有，给出最早产生碰撞的时间。

下面的解析结合代码看会更加清晰。每个机器人会给一个向量f表示初始在立方体的哪个面和一个向量d表示初始前进的方向，题目保证f和d是互相垂直的，后续机器人只会在f和d所在的平面内运动，所以三维坐标有一个轴的坐标是可以忽略的，并且由于空间站都是立方体，机器人的运动轨迹一定是周期循环的。
首先要对题目给出的坐标乘以2，因为机器人出发点是立方体表面的中心，所以乘2可以避免小数的出现，并且不需要额外的记录表达机器人是在哪个面。由于f和d组成了运动平面的一组基，可以把空间站立方体的坐标转换成以f和d为基的坐标，这样的好处是不用考虑运动方向的影响，并且只需要处理二维。转换成fd坐标后，f和d上各自的坐标再加入+∞和-∞，两个坐标轴的坐标分别排序，这样就将坐标化成了排序后的下标，这样做是因为坐标的绝对值在这个问题中是无关紧要的，只需要知道它们的大小关系。经过这样的操作后，坐标就被简化成了一个点阵（grid），通过泛洪算法将空间站在fd平面的切面的边界找出来，就可以找出机器人的运动轨迹。
找出运动轨迹后，还原成三维坐标，每两个机器人的轨迹的每一段互相判断一下是否有相交，并算出碰撞时间（通过解同余方程组），所有机器人算完之后就可以得到最早的碰撞时间了。

#L Sweep Stakes
有一个mxn大小的雷场，每个格子有无地雷都有一个概率，各个格子间有无地雷都是独立的，已知雷场内一共有t个地雷，给定一些查询，每个查询指定了s个格子，要你给出这些格子内有0-s个地雷的概率。

这个题实际上就是求一个条件概率，一共mxn个概率独立的格子中恰好有t个雷的概率，其实就是一个二项分布，求出来就好了。每个查询中的s个格子，有i个地雷的概率，等于s个格子中有i个地雷的概率乘以mxn-s个格子中有t个地雷的概率。由于已知一共有t个地雷了，两个概率相除才是需要求的条件概率，已知共有t个雷的情况下，s个格子中有i个雷。
原理是这样，但是如果每个查询都单独计算一次s个格子中有0-s个地雷的概率，复杂度就太高了。由于mxn最多有250000个，s最多只有500个，所以可以想办法把mxn-s个格子中有地雷概率的很多重复计算合并。将相邻的两个查询作为二叉树的左右节点，其格子集合就是它们要查询的格子，父节点的格子集合定为子节点的格子集合的并，一直往上合并构造树直到产生一个根节点。然后从根节点深度优先遍历，每到达一个节点，就计算全集减去节点格子集中有地雷的概率，因为从根往下，减集是越变越大的，所以节省了大量计算。
另外，为了减少计算数量，定义一个极小值ε，当计算出的概率小于ε，直接将其置为0，由于二项分布的曲线特征是两边低中间高，这样可以不计算很多长尾（头）概率。由于最后的概率要求误差小于10^-6，所以ε的值可以定义为10^-12。

#