#B Dungeon Crawler
##题目大意
有一个有n个房间的dungeon，共有n-1条走廊连接这些房间，每一条走廊有它的通过需要的时间。在每一个场景q中，地牢的其中两个房间被标记为K和T，并给出一个起点S，要求找出遍历完整个地牢并且先经过K再经过T的最少时间。可能不存在这样的路径，这种情况输出impossible。
##解法
n个节点，n-1条边，所以这个dungeon是一棵树，树边的权值是通过时间t。这道题目的本质是找树上的最长路径。
假设当树中没有K和T点，那么题目可以简化为找到从S点出发的树中最长的路径。沿着这条最长路径遍历整棵树，就可以得到最短的遍历长度，为树中所有边的长度的总和的两倍减去这个最长路径的长度。
![](tree.jpg)
如图中的树，红色的是最长路径，遍历过程中红色的路径只会经过一次，其余的黑色路径均会经过两次，一出一入。
现在的难点是最长路径需要先经过K点再经过T点。在每个场景中，固定了S、K、T三点，由于dungeon是一颗树，所以S到K，S到T的路径是存在且唯一的。设路径SK和ST的分叉点为J。
![](joint.jpg)
现在依然是要遍历树中的每个节点，寻找最长路径，对于不经过JK段的最长路径，不用做特殊处理，用它的长度计算即可；但对于经过JK段的路径，如图中从JK中间的J'分岔出去的路径，由于从S出发要先到K，然后再到T，再从J‘离开，所以JJ'间的节点实际经过了三次，所以计算最长路径的时候，要用路径长度减去JJ'之间的长度作为路径值。
基础的原理还是很简单的，接下来要做的就是加速计算