#B Dungeon Crawler
##题目大意
有一个有n个房间的dungeon，共有n-1条走廊连接这些房间，每一条走廊有它的通过需要的时间。在每一个场景q中，地牢的其中两个房间被标记为K和T，并给出一个起点S，要求找出遍历完整个地牢并且先经过K再经过T的最少时间。可能不存在这样的路径，这种情况输出impossible。
##解法
n个节点，n-1条边，所以这个dungeon是一棵树，树边的权值是通过时间t。这道题目的本质是找树上的最长路径。
假设当树中没有K和T点，那么题目可以简化为找到从S点出发的树中最长的路径。沿着这条最长路径遍历整棵树，就可以得到最短的遍历长度，为树中所有边的长度的总和的两倍减去这个最长路径的长度。
![](tree.jpg)
如图中的树，红色的是最长路径，遍历过程中红色的路径只会经过一次，其余的黑色路径均会经过两次，一出一入。
现在的难点是最长路径需要先经过K点再经过T点。在每个场景中，固定了S、K、T三点，由于dungeon是一颗树，所以S到K，S到T的路径是存在且唯一的。设路径SK和ST的分叉点为J。
![](joint.jpg)
现在依然是要遍历树中的每个节点，寻找最长路径，对于不经过JK段的最长路径，不用做特殊处理，用它的长度计算即可；但对于经过JK段的路径，如图中从JK中间的J'分岔出去的路径，由于从S出发要先到K，然后再到T，再从J‘离开，所以JJ'间的节点实际经过了三次，所以计算最长路径的时候，要用路径长度减去JJ'之间的长度作为路径值。
基础的原理还是很简单的，现在算一下朴素算法的复杂度。从树中一点出发找它能到达的最长路径，可以从这点出发进行DFS，复杂度是O(N)；对n个节点进行操作，一共进行q次，复杂度就是O(qn)。在这里q可以达到2x10^4，所以要进行优化，以空间换时间，对一些计算结果进行缓存，使得每次查询的复杂度降低到O(logN)，总体复杂度降低到O(qlogN)。
第一步，以0号节点为根节点，通过一遍DFS，算出每个节点的高度和它通过每一个子节点分别能到达的最长距离。然后进行第二遍DFS算出每个节点从它的父节点离开能到达的最长距离，因为第一次的DFS已经算出每个节点从它的子节点离去的最长距离，第二遍DFS遍历到子节点的时候，父节点已经计算完成，所以父节点已经得到了从它所有邻接节点离开能到达的距离，所以可以算出当前节点通过它的父节点能到达的最长距离。完成第二遍DFS后，就得到了所有节点通过其邻接节点离去能到达的最大距离。这一步的复杂度是O(N)。
朴素的算法中提到了S到K的路径是求解问题的关键，由于这里人为的规定了0号节点为根节点，所以SK路径也可以人为的分为向上朝着根节点方向和向下离开根节点方向的两段。问题要求的是从S出发能到达的最长路径，并且这条最长路径与SK的分岔点J'和SK与ST的分岔点J之间的距离要被减去。第二步，就需要对每个节点计算一些调整好的距离数据，缓存起来，加速后面在SK路径上遍历每个节点的计算。
具体的缓存方法是树上的二进制跳转，计算缓存的过程也是DFS。通过第一遍DFS算出的每个节点的高度，根据高度的二进制表示的最后面0的个数，缓存它的对应的2^n号的祖先，比如高度为24即11000，就缓存这个节点的祖先路径上的1、2、4、8号祖先（1号祖先是父节点，2号祖先是爷爷节点），以及祖先路径上这个2^n祖先的前一个节点。这样的好处是，过来任意一个高度的节点，比如高度的二进制表示为1100111，通过一次跳转到高度为1100110，二次跳转到1100100，三次跳转到1100000，四次1000000，五次跳转到根节点。即每个节点都可以通过O(logN)次的跳转到达根节点。沿着SK路径遍历也可以改为沿着SK路径上的2^n祖先遍历，从而把O(N)次遍历优化为O(logN)次遍历。为了能在跳转遍历的时候就能获得路径上的点的最长路径值，第二步中就要通过dp计算出这些值并缓存起来。
对每个节点缓存它的2^n号祖先