#B Dungeon Crawler
##题目大意
有一个有n个房间的dungeon，共有n-1条走廊连接这些房间，每一条走廊有它的通过需要的时间。在每一个场景q中，地牢的其中两个房间被标记为K和T，并给出一个起点S，要求找出遍历完整个地牢并且先经过K再经过T的最少时间。可能不存在这样的路径，这种情况输出impossible。
##解法
n个节点，n-1条边，所以这个dungeon是一棵树，树边的权值是通过时间t。这道题目的本质是找树上的最长路径。
假设当树中没有K和T点，那么题目可以简化为找到从S点出发的树中最长的路径。沿着这条最长路径遍历整棵树，就可以得到最短的遍历长度，为树中所有边的长度的总和的两倍减去这个最长路径的长度。
![](tree.jpg)
如图中的树，红色的是最长路径，遍历过程中红色的路径只会经过一次，其余的黑色路径均会经过两次，一出一入。
现在的难点是最长路径需要先经过K点再经过T点。在每个场景中，固定了S、K、T三点，由于dungeon是一颗树，所以S到K，S到T的路径是存在且唯一的。设路径SK和ST的分叉点为J。
![](joint.jpg)
现在依然是要遍历树中的每个节点，寻找最长路径，对于不经过JK段的最长路径，不用做特殊处理，用它的长度计算即可；但对于经过JK段的路径，如图中从JK中间的J'分岔出去的路径，由于从S出发要先到K，然后再到T，再从J‘离开，所以JJ'间的节点实际经过了三次，所以计算最长路径的时候，要用路径长度减去JJ'之间的长度作为路径值。
基础的原理还是很简单的，现在算一下朴素算法的复杂度。从树中一点出发找它能到达的最长路径，可以从这点出发进行DFS，复杂度是O(N)；对n个节点进行操作，一共进行q次，复杂度就是O(qn)。在这里q可以达到2x10^4，所以要进行优化，以空间换时间，对一些计算结果进行缓存，使得每次查询的复杂度降低到O(logN)，总体复杂度降低到O(qlogN)。
第一步，以0号节点为根节点，通过一遍DFS，算出每个节点的高度和它通过每一个子节点分别能到达的最长距离。然后进行第二遍DFS算出每个节点从它的父节点离开能到达的最长距离，因为第一次的DFS已经算出每个节点从它的子节点离去的最长距离，第二遍DFS遍历到子节点的时候，父节点已经计算完成，所以父节点已经得到了从它所有邻接节点离开能到达的距离，所以可以算出当前节点通过它的父节点能到达的最长距离。完成第二遍DFS后，就得到了所有节点通过其邻接节点离去能到达的最大距离。这一步的复杂度是O(N)。
朴素的算法中提到了S到K的路径是求解问题的关键，由于这里人为的规定了0号节点为根节点，所以SK路径也可以人为的分为向上朝着根节点方向和向下离开根节点方向的两段。问题要求的是从S出发能到达的最长路径，并且这条最长路径与SK的分岔点J'和SK与ST的分岔点J之间的距离要被减去。第二步，就需要对每个节点计算一些调整好的距离数据，缓存起来，加速后面在SK路径上遍历每个节点的计算。
具体的缓存方法是树上的二进制跳转，计算缓存的过程也是DFS。通过第一遍DFS算出的每个节点的高度，根据高度的二进制表示的最后面0的个数，缓存它的对应的2^n号的祖先，比如高度为24即11000，就缓存这个节点的祖先路径上的1、2、4、8号祖先（1号祖先是父节点，2号祖先是爷爷节点），以及祖先路径上这个2^n祖先的前一个节点。这样的好处是，过来任意一个高度的节点，比如高度的二进制表示为1100111，通过一次跳转到高度为1100110，二次跳转到1100100，三次跳转到1100000，四次1000000，五次跳转到根节点。即每个节点都可以通过O(logN)次的跳转到达根节点。沿着SK路径遍历也可以改为沿着SK路径上的2^n祖先遍历，从而把O(N)次遍历优化为O(logN)次遍历。为了能在跳转遍历的时候就能获得路径上的点的最长路径值，第二步中就要通过dp计算出这些值并缓存起来。
通过动态规划，计算出跳转到2^n祖先的过程中经过的节点所能到达的最长路径，由于人为定义了树根，所以跳转分为上下两个方向，又由于路径分为与JK段重叠和不重叠，所以一共要通过DP计算出2x2=4类缓存结果。
以往上走不重叠为例，对于每个节点，前面根据其高度的二进制表示计算了若干个祖先，对于每个祖先，需要计算出，到达这个祖先，但不从这个祖先进入其它分支子树（这里很重要，因为无法确定其它分支子树在后续的query中会不会和JK段重合，所以只能计算到这个祖先为止），所能达到的最长路径。 对2^n祖先的最长路径的计算，可以用以下三个值的最大者得出：1.当前点到2^(n-1)级二进制祖先能达到的最大路径；2.当前点到2^(n-1)二进制祖先，然后转入它的另一子树，所能到达的最大路径；3.当前点到2^(n-1)二进制祖先，然后从那里走2^(n-1)二进制祖先到达它的2^(n-1)祖先（亦即当前点的2^n祖先）的最长路径。写成递推式UpNotOverlap[x][n]=max(UpNotOverlap[x][n-1], dist[x][n-1] + max(maxPathTurningIntoOtherSubTree[ancestor[x][n-1]], UpNotOverlap[ancestor[x][n-1]][n-1]))。
对于往下不重叠的路径计算也是类似的。而对于重叠版本的，由于到达2^(n-1)祖先的部分是与JK重合，所以在遍历中被走过3次，所以在计算最长路径的过程中，将这段的长度减去即可。
得到动态规划的结果后，每进来一个查询，只需要对SKT计算出到达路径，得到它们的公共祖先，将它们之间的路径划分成向上向下重叠不重叠4部分，然后通过之前的动态规划结果计算最长路径即可。