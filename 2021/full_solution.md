这一年忙着卖py，还有打羽毛球，都没什么时间做ICPC 2021的题，最近刚好给炒鱿鱼了，又有时间写了。

#A Crystal Crosswind
##题目大意
有一个dx x dy大小的晶体结构，‘#’的位置是晶体, '.'的位置是空格。科学家用指定方向的wind去窥探晶体，可以得出晶体的一部分边界结构，现在要你根据这些wind吹出来的结果，输出晶体可能的结构中，具有最多和最少晶格的两种结构。
##解法
这个题在这里面是挺简单的，首先建一个dx x dy的char二维数组graph来表示晶格结构，每个位置有三种取值‘?’、'.'和'#',分别代表未知,空位和晶格三种情况.最终的结果中,晶体结构一定包含了这三种符号,其中'#'和'.'代表这个位置一定是晶格或者空,而'?'的位置则可能是'#'或'.',分别把'?'替换成#和.,就可以得到最多和最少的两种结构了.
首先读入wind得到的'#'位置的数据,将graph中对应位置置为?,要注意,#位置对应的wind发出的位置,要置为.,否则这个位置是不可能探测出这个#的.然后遍历这个grid,并通过dfs或者bfs,将部分?识别为正确的#或.,减少未知的数量.
识别的依据有三条:
1.对于一个'#',如果它的上风位是'?',那这个'?'一定是一个'#'，否则如果'?'是'.',那么wind在扫到这个'.'的时候,第一个'#'会被认定为boundary,并且这个'?'在读入数据的时候就会被置为'.'，与当前状态矛盾了.
2.对于一个'.',如果它的下风位是‘?',那这个'?'一定是’.‘，否则如果'?'是'#'，那它一定是boundary，不可能没被发现
3.被wind从dx x dy的范围外指进来的'?'只能是'.'，如果是'#'也肯定会在boundary的列表内
最后根据graph中的状态输出两个结果就行了

#B Dungeon Crawler
##题目大意
有一个有n个房间的dungeon，共有n-1条走廊连接这些房间，每一条走廊有它的通过需要的时间。在每一个场景q中，地牢的其中两个房间被标记为K和T，并给出一个起点S，要求找出遍历完整个地牢并且先经过K再经过T的最少时间。可能不存在这样的路径，这种情况输出impossible。
##解法
n个节点，n-1条边，所以这个dungeon是一棵树，树边的权值是通过时间t。这道题目的本质是找树上的最长路径。
假设当树中没有K和T点，那么题目可以简化为找到从S点出发的树中最长的路径。沿着这条最长路径遍历整棵树，就可以得到最短的遍历长度，为树中所有边的长度的总和的两倍减去这个最长路径的长度。
![](tree.jpg)
如图中的树，红色的是最长路径，遍历过程中红色的路径只会经过一次，其余的黑色路径均会经过两次，一出一入。
现在的难点是最长路径需要先经过K点再经过T点。在每个场景中，固定了S、K、T三点，由于dungeon是一颗树，所以S到K，S到T的路径是存在且唯一的。设路径SK和ST的分叉点为J。
![](joint.jpg)
现在依然是要遍历树中的每个节点，寻找最长路径，对于不经过JK段的最长路径，不用做特殊处理，用它的长度计算即可；但对于经过JK段的路径，如图中从JK中间的J'分岔出去的路径，由于从S出发要先到K，然后再到T，再从J‘离开，所以JJ'间的节点实际经过了三次，所以计算最长路径的时候，要用路径长度减去JJ'之间的长度作为路径值。
基础的原理还是很简单的，现在算一下朴素算法的复杂度。从树中一点出发找它能到达的最长路径，可以从这点出发进行DFS，复杂度是O(N)；对n个节点进行操作，一共进行q次，复杂度就是O(qn)。在这里q可以达到2x10^4，所以要进行优化，以空间换时间，对一些计算结果进行缓存，使得每次查询的复杂度降低到O(logN)，总体复杂度降低到O(qlogN)。
第一步，以0号节点为根节点，通过一遍DFS，算出每个节点的高度和它通过每一个子节点分别能到达的最长距离。然后进行第二遍DFS算出每个节点从它的父节点离开能到达的最长距离，因为第一次的DFS已经算出每个节点从它的子节点离去的最长距离，第二遍DFS遍历到子节点的时候，父节点已经计算完成，所以父节点已经得到了从它所有邻接节点离开能到达的距离，所以可以算出当前节点通过它的父节点能到达的最长距离。完成第二遍DFS后，就得到了所有节点通过其邻接节点离去能到达的最大距离。这一步的复杂度是O(N)。
朴素的算法中提到了S到K的路径是求解问题的关键，由于这里人为的规定了0号节点为根节点，所以SK路径也可以人为的分为向上朝着根节点方向和向下离开根节点方向的两段。问题要求的是从S出发能到达的最长路径，并且这条最长路径与SK的分岔点J'和SK与ST的分岔点J之间的距离要被减去。第二步，就需要对每个节点计算一些调整好的距离数据，缓存起来，加速后面在SK路径上遍历每个节点的计算。
具体的缓存方法是树上的二进制跳转，计算缓存的过程也是DFS。通过第一遍DFS算出的每个节点的高度，根据高度的二进制表示的最后面0的个数，缓存它的对应的2^n号的祖先，比如高度为24即11000，就缓存这个节点的祖先路径上的1、2、4、8号祖先（1号祖先是父节点，2号祖先是爷爷节点），以及祖先路径上这个2^n祖先的前一个节点。这样的好处是，过来任意一个高度的节点，比如高度的二进制表示为1100111，通过一次跳转到高度为1100110，二次跳转到1100100，三次跳转到1100000，四次1000000，五次跳转到根节点。即每个节点都可以通过O(logN)次的跳转到达根节点。沿着SK路径遍历也可以改为沿着SK路径上的2^n祖先遍历，从而把O(N)次遍历优化为O(logN)次遍历。为了能在跳转遍历的时候就能获得路径上的点的最长路径值，第二步中就要通过dp计算出这些值并缓存起来。
通过动态规划，计算出跳转到2^n祖先的过程中经过的节点所能到达的最长路径，由于人为定义了树根，所以跳转分为上下两个方向，又由于路径分为与JK段重叠和不重叠，所以一共要通过DP计算出2x2=4类缓存结果。
以往上走不重叠为例，对于每个节点，前面根据其高度的二进制表示计算了若干个祖先，对于每个祖先，需要计算出，到达这个祖先，但不从这个祖先进入其它分支子树（这里很重要，因为无法确定其它分支子树在后续的query中会不会和JK段重合，所以只能计算到这个祖先为止），所能达到的最长路径。 对2^n祖先的最长路径的计算，可以用以下三个值的最大者得出：1.当前点到2^(n-1)级二进制祖先能达到的最大路径；2.当前点到2^(n-1)二进制祖先，然后转入它的另一子树，所能到达的最大路径；3.当前点到2^(n-1)二进制祖先，然后从那里走2^(n-1)二进制祖先到达它的2^(n-1)祖先（亦即当前点的2^n祖先）的最长路径。写成递推式UpNotOverlap[x][n]=max(UpNotOverlap[x][n-1], dist[x][n-1] + max(maxPathTurningIntoOtherSubTree[ancestor[x][n-1]], UpNotOverlap[ancestor[x][n-1]][n-1]))。
对于往下不重叠的路径计算也是类似的。而对于重叠版本的，由于到达2^(n-1)祖先的部分是与JK重合，所以在遍历中被走过3次，所以在计算最长路径的过程中，将这段的长度减去即可。
得到动态规划的结果后，每进来一个查询，只需要对SKT计算出到达路径，得到它们的公共祖先，将它们之间的路径划分成向上向下重叠不重叠4部分，然后通过之前的动态规划结果计算最长路径即可。

#C Fair Division
##题目大意
有n个海盗要分价值为m的赃物,每个人轮流拿一个比例f=p/q,直到无穷,要求最后每个海盗分到的都是一个整数,要求出这个最小的p和q,不可行就输出impossible
##
这是一个数论的题目.首先求解无穷级数,看看每个海盗分别分到多少
![](pirate.jpg)
对于第k个海盗，他能分到的数量由上式给出，要每个海盗都分到整数，只需要mp/(q^n-(q-p)^n)是整数就可以了
![](qmin.jpg)
另外化简一下式子，可以得出，当n>60时，一定是找不到f的解的。
接下来从q=2，p<q，一个个试能不能使mp/(q^n-(q-p)^n)是整数就可以了

#D Guardians of the Gallery
##题目大意
有一个由若干个顶点构成的多边形美术馆，在坐标S处有一个需要看守的雕像，有一个保安看门，他的起始坐标在G点。当保安移动到能够直视到雕像的位置即可。要求保安从居点出发，移动的最短距离。
##解法
这道题是一道计算几何的题目，但求最短路径的过程又用到了图论里的擦dijkstra算法。首先看两个典型的路径。
![](sample1.png)
![](sample2.png)
蓝点是G点，红点是S点。一个最短的路径肯定是从G出发，然后经过若干个多边形的顶点，最后到达多边形内的一点E，在这个点上可以直接看到S。
首先来分析一下多边形内哪些区域可以满足要求。图中标红的区域就是满足视线要求的区域，可以看到终点E一定是区域的边界上的一点。
![](region1.jpg)
像示例2这种特殊情况，①号区域由于只有单边有遮挡所以可以满足要求，而②号区域，双边都有遮挡，就不满足要求了。
![](region2.jpg)
第一步要把所有可能的终点E找出来，这些E点其实就是视野区域上面的临界点。首先通过S点向多边形的每一个顶点做射线，找出沿着射线能到达的最远的视野不被遮挡的点(图4的绿点，图3射线和水平的上边的交点)，这部分点是潜在的E点。然后对每条射线，遍历多边形的所有顶点，找出这些顶点到射线的垂直交点（就是求顶点到射线的最短距离，图3的绿点），这部分点也是潜在的E点。
求出所有的E点后，问题就变成了从G点出发，途经若干个多边形的顶点，然后到达一个E点，求一个最短距离。这里就变成了图论中的求从单是的一源点，到其他点的最短路径，可以使用dijkstra算法。初始的时候，将G点加入优先队列，当优先队列的根节点变成一个E点的时候，就可以结束求最短路径了，这个E点就是最短路径的终点。

#E Hand of the Free Marked
谁能想到啊，这题逼逼赖赖了一大通，其实就是个求排列组合的题。。。当M=1的时候，答案是min(A(N,K-1)/C(N,K) , 1)，即K-1张牌的排列总数是否可以表示所有K张牌的组合数。当M>1的时候，需要对K张牌分别每一类各有几张单独计算（因为魔术师看到牌的正面会知道牌的背面是什么颜色，最后一张反转的牌他能看到是什么颜色，所以他知道抽出来的牌各种颜色有多少，每种颜色组合可以作为一个独立子问题），如K=3，M=2，黑红两种牌各有5张，需要分为3黑，2黑1红，1黑2红，3红，4种情况算，以算2黑1红的概率为例，(C(5,2)+C(5,1)·C(5,1))·A(2,2)/C(5,2)·C(5,1)，2张用作排列的牌均从黑取，或一黑一红，除以总的3张牌组合数。总的概率就是4种情况的和。

#F Islands from the Sky
##题目大意
有一片由若干多边形构成的群岛，现在有若干条飞机航线，在每架飞机底部安装一个向两周拍摄为θ的摄像头，飞机飞行的线路是直线，起点终点海拔可能不一样，所以每架飞机能拍摄到的区域是一个梯形.同时要求每个岛都至少被一条航线完整拍摄一遍,如果有一个岛,没有一条航线能拍完整,即使多条航线能覆盖它的全部区域,也是不行的.现在问能够拍到群岛全景的最小θ是多少，如果拍不了全景输出impossible
##解法
由于是找一个对所有飞机生效的全局的θ，且只要求θ与正确值的误差在10^-6的范围内，所以可以用二分查找的方法确定θ的一个范围，并使范围小于10^-6就行了。
因为90÷2^27=0.00000067055225372314453125<10^-6, 所以只需要二分27次就足够了.
初始θ的范围定为(0,90°), 取区间的中点45°, 计算出航线得到的所有梯形, 是否能覆盖每一个岛, 并且每个岛都被某条航线拍完整了,判断方法可以用梯形是否包含岛的每一个顶点.梯形是否包含一个点,通过在这个点向任意方向,作一条无穷远的射线,看和梯形的4条边,相交了几次,如果是奇数次那么梯形包含这个点,偶数次就不包含.
如果这个θ能够包含所有岛屿,就将它设为区间上界,否则设为下界.如果最后θ还是90°,那么就是无法覆盖群岛,输出impossible.

#G Mosaic Browsing
##题目大意
有一个rq x cq大小的方块mosiac,每一块都是一种颜色,还有一个rp x cp的pattern motif,里面的一些块有颜色,还有一些没颜色的通配符,现在要在mosiac里找出所有能和motif匹配上的位置.
##
这是一个二维的匹配问题,如果用滑动窗口逐一匹配的话,复杂度达到O(rpxcpxrqxcq),运行太久了。注意到问题限定只有100种颜色，可以采用通过颜色区分的图层去匹配。并每次用motif的一列去匹配mosaic的列的部分。

#K Take on Meme
minkowski sum
https://cp-algorithms.com/geometry/minkowski.html