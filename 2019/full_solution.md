#ICPC World Final 2019 完全题解
19年的题目出的真的不错，题目设定的场景很合理，有实际有意义。但看遍网上都没有发现比较完整的带代码的题目解析，一般只能找到些AC的代码，但这些代码的可读性也不好，或者就是随便讲两句的题解，参考意义不够大。同时官方的解析和视频有些地方比较模糊甚至是错的，所以在写完了19年的所有题目后，打算写一篇2019年world final的完全的题解。解析全部有代码配对，代码也是详细注释过的，欢迎各位查看，互相学习指正。代码链接https://github.com/CptJack2/icpc-challenge/tree/master/2019
我做题的顺序是F -> A -> B -> H -> I -> J -> E -> D -> G -> C -> K -> G，刚好第一题就几乎是实现上最难的一题，反而第一题用的时间最久。
另外，某些题的解法需要自行先了解一些算法的原理，比如AC自动机、倍增算法、查找连通分量等等，这篇里面没有详细写这些算法的原理，如果这篇的点赞超过3000，我就考虑再详细写写这些算法的解析吧。

#一点资料
我写的代码链接     https://github.com/CptJack2/icpc-challenge/tree/master/2019
一个大神的代码，简洁易懂，可以参考一下       https://github.com/SnapDragon64/ACMFinalsSolutions
ICPC官网，有问题描述、解析、测试数据下载         https://icpc.global/worldfinals/problems
官方解析视频          youtube搜一下题目名即可，b站或许也有
在线oj        https://icpc.kattis.com/problem-sources/ACM-ICPC%20World%20Finals%202019

#测试我的代码
每个目录下都有test_case.sh，在linux或者wsl下面可跑，把下载的测试数据放到指定的路径，编译好程序，跑sh就可以了。

下面正式开始咯

#A Azulejos
##题目大意
要将两排砖按照以下条件排列：1.前排的要严格矮于后排的。2.每一排的价格从左到右需要是越来越贵（可以相等）
##解法
贪心法即可，这题算是最简单的了。首先将两排砖分别按价格排序，价格相同的划到同一个set。然后都从最低价开始，拿出前排当前最低价的一块砖摆上（多块的话随意摆一块），然后到后排的当前最低价的砖里面找一块刚好能满足要求的（刚好比前排的高1个单位，没有的话就是比这个高的最矮的），一直到摆完就可以了；要是这时候找不到这样的砖（就是最低价的都比前面的矮），那就知道没法摆了（后排的有砖匹配不上前排，前排出现同样的情况也是一样），直接输出impossible。
由于只需要遍历所有砖块一遍就可以解决，所以复杂度是O（N）的。

#B Beautiful Bridges
##题目大意
在一段崎岖的山路（分段的折线）上建拱桥，要求桥面是平的，桥的海拔高度也指定了。只能在折线的端点上建柱子，每两个柱子间要建圆拱。建柱子的单位费用是α，建圆拱的费用是β，求建桥耗费最少的价格。
##解法
用动态规划的方法求解，用数组dp[i]（i∈[0,n]，dp[i]初始化为∞）表示从0点到i点建桥的最少费用，令i：0→n，j:i+1→n，不断尝试在ij间建圆拱，如果相比前面的方案这个方案更优，就更新dp数组。最后dp[n]就是最小费用，如果是∞就是无解。
建圆拱时，需要先求从i点能够建造的圆拱的半径的最大值和最小值。设i点x坐标为0，圆拱的半径为R，hi是i处桥平面到山顶的高，首先有0<=R<=2*hi。
然后遍历后面的每一点j，设H是桥海拔高度，d为ij间水平距离，hj是j处桥平面到山顶的高。那么圆心坐标就是（R，H-R), j点坐标是（d,H-h)。对于每一个j点，都要保证桥拱能越过j点的山顶，即满足不等式(R-d)^2+(R-h)^2<=R^2(根据圆心到j点的距离为R，勾股定理列出方程。不等式通过一元二次方程的通解公式解。)。同时，对于j点建造的圆拱，同样有R<=2*hj，如果j点不能构造那么大的圆拱，那么i点的圆拱必须要跨过j点，因此圆拱半径必须大于使得j点刚好擦过圆拱右半边的半径。
这样不断遍历j点，收缩圆拱的可行半径，判断是否更优答案，就可以得到答案。根据上面的分析，整个求解复杂度为O(N^2)。

#C Checks Post Facto
##题目大意
有一种叫Checkers的棋类游戏，现在有一系列棋谱，要通过棋谱还原出原来的可能的局面。
规则如下：
棋子分为两种，小兵和大王，兵只能往前斜走，王能往回走，隔着对方的子跳过去能吃棋。兵到了对面底线能晋升王。
如果当前局面能吃子，必须先吃子。
##解法
题目算法不难，难处在于实现上有特别多细节需要注意。
首先需要正序遍历一遍棋谱，把棋谱上移动了的棋子但棋盘上没有的，给它摆上去。摆的时候，优先摆man（因为移动方向只有2个，后面检查jump优先的时候更方便），不符合规则才换成king。同时把jump中被吃掉的子也补上，并且处理吃子和晋升的情况。
下面是检查局面是否符合jump优先的规则，再次正序跑一遍棋谱，如果有不符合的情况，需要用一些从头到尾未被移动过的棋子去挡住这个可能jump的路线。由于不确定这个位置是放黑棋还是白棋，所以两种情况都要递归地试一下。
由于棋盘只有32个位置，问题规模较小，所以复杂度对时间的影响不大。

#D Circular DNA
##题目大意
有一个环形的DNA，有若干种类型的基因子，每种类型的基因子都只有s和e两类，类型写在下标，基因子长si或者ei这样的样子。现在在圈上顺便找一个位置剪一刀，得到一个线性序列。
现在，在这个线性序列中，如果一个下标类型i的基因子，都是s在前e在后，像括号一样对的上的话，那么这一个类型就是properly nested的
问你在环形DNA中哪里剪开，能使得最多的下标类型properly nested。
##解法
先从0号位开始剪开，对每一种下标类型维护一个counter，记录能够互相匹配的s减去e的数目，再记录一个没有被匹配上的e的数目。当一个类型properly nested，等价于它的counter的两个记录都为0。
然后可以按照逆时针或者顺时针的顺序调整切点，并更新counter，并更新properly nested的类型的数量，转完一圈后最大的就是答案了。
我是逆时针调整切点更新的，有一个简化的窍门，如果counter的两个记录不相等，那么这个类型的s和e数量一定是不匹配的，直接不管它了，具体可以看看代码。调整时，只需看看当前变更的这个基因子。逆时针调整，相当于把当前的队尾移动到队头，如果是s可能会匹配上之前没匹配的e，如果是e那一定是拆对了，把counter调整好就可以。
最后复杂度是O(N)的，很快。

#E Dead-End Detector
##题目大意
有一个街道的地图，是个无向图（也可以理解是双向车道）。如果你的车从某个点开出，不在某个地方来个180°掉头，是回不到这个点的，那么那个点的那一个出口，就要安一个此处是死路的标志。同时，为了省钱，一条有向的路径（经过若干个点）上，只在开头安装标志（其它地方应装的不装）。现在问你最少要装多少个标志，以及装在哪。
##解法
首先，图里面可能存在多个连通分量，先找出各个连通分量，单独处理。
然后，每个连通分量分为是树（度的和等于结点数减一）和不是树（度的和大于等于结点数）两种情况。
如果是树的话，只需要在每个叶子结点（度为1）处安装标志即可，因为树中任何一点都是一定要掉头才能回去的，而叶子结点之外的节点的每个路口，肯定可以从一个叶子结点作为起点到达，所以标志就省了。
如果不是树的话，那么不断把度为1的叶子结点删掉，更新他的去向结点的度，一直删到没有度为1的点为止。这样的删法到最后剩下的一定是一些环，被删掉的都是一些树根在环上的树上的结点（就像H题里面的那样），最后在环上通向树上的口放标志即可。因为树上的结点可以通过树根到环上转一圈再回来，是没有死路的；环上的结点到树上一定是死路，所以在树根放一个。
最后复杂度为O(N+E)，N是结点数，E是度，因为每个结点和连线都被遍历了常数次。

#F Directing Rainfall
这个单独写过一篇，链接如下。
https://zhuanlan.zhihu.com/p/465894918

#G First of Her Name
#题目大意
有一个贵族，她们的名字是在祖先的名字前加一个字母。现在给一个这样的族谱，还有若干个字符串，问你以这个字符串作为前缀的女王有多少个。
题目很简明扼要，这个题有两种解法。
#解法一
首先每个女王只有一个祖先，根据输入构造出来的就是一颗字典树。首先对字典树用倍增算法找出他2^n次方的祖先。如果不了解倍增算法，可以网上搜一下，或者搜英文关键词binary lifting。同时这里采取构造后缀数组(suffix array)的类似的排序方法，不了解的同样可以搜一下，对字典树中的节点进行排序（每一个节点代表一个人名）。最后得出一个按字典序排序过的有序的数组，用二分查找就可以得出以某个字符串为前缀的女王有多少个了。
简单讲一下排序的具体方法，一开始先按第一个字母的字典序为每个节点赋予一个初始排序，只计算不同的字母（相当于sql里面的count distint）。然后，每次排序将参与排序的串长度翻倍（利用了后缀数组的性质，一个串总可以作为另一个串的后缀），排序的关键字就有了两个，第一关键字就是跟这个节点绑定的排名，第二关键字就是它倍增祖先节点绑定的排名（binary lifting在这里用到了）。两个关键字再次排好序后（这里的排序同样是count distinct的），更新节点绑定的排名。因为每个女王名字保证不同，所以排序总是有且唯一的。
最后算法复杂度binary lifting部分因为是DFS，所以是O(N)，排序部分因为要进行logN次O(NlogN)的快排，所以是O(N(logN)^2)。提一句，这里的排序方法如果不是快排，而是基数排序的话，理论可以达到O(NlogN)（logN次O(N)的基数排序），但我实际写的时候这样是超时的，可能我写的不对，附上了代码和火焰图，有兴趣的朋友可以研究研究。
还有另外一个比较坑的东西，查询的字符串中可能有重复的，这个注意一下就好。
#解法二
解法二相当有意思，用到了AC自动机（Aho-Corasick Automaton）和与AC自动机相关的fail树，需要先自行了解这个算法。
首先需要把女王名字反转过来，加到前面的就变成了加到后面，查询前缀变成查询后缀，还是建出字典树。然后把查询的字符串也加入到字典树里面。然后在字典树上面建立AC自动机，由于字典集是{A-Z}的有限集，每个节点添加遇到每一个字符的快速跳转表，建立好failure link，同时建好fail树。简单讲一下fail树，由于每个节点只有一个failure的出链接，最后都会一直汇聚到树根，这样就变成一个fail树。最后求答案的时候，为字典树中每个节点赋初值0，对代表女王名字的节点赋值1，最后通过一次dfs，父节点的值取所有子节点的值的和。dfs完后，代表查询字符串的点上的值就是答案。
这里利用的就是沿着failure链接转移，下家是上家的最长后缀，的性质。由于普通的AC自动机只能统计某个词有没有出现过，要统计词频需要不断沿着failure转移，对同样后缀的词也进行统计，这样就会耗时更多，在这里某个测试用例会超时；利用fail树的结构做一次dfs就可以直接知道词频了，上限是O(N)。
整个算法的复杂度是O(N)。

#H Hobson's Train
单独有过一篇题解。
https://zhuanlan.zhihu.com/p/463659649

#I Karel the Robot
单独有过一篇题解。
https://zhuanlan.zhihu.com/p/458367433

#J Mininature Golf
##题目大意
p个人一起打高尔夫，一共有h局，每局每人一个杆数。打完之后，他们想为杆数设一个最大值调整得分，如果那一局杆数超过最大值就把杆数改成最大值。问在不同的杆数最大值下，每个人的最高排名分别是多少。
##解法
对于每个人的总杆数，关于杆数限制的函数，是一个分段线性函数。如图所示。当限制超过他的最大杆数，直线是平的，前面的线段的斜率，就是这个人有多少杆的得分超过了这一个限制。
![img.png](img.png)
首先将每个人自己的分数进行一个从大到小的排序。用两重循求出每个人的最佳排名，外层循环每次处理一个人；内层循环遍历其他所有人。内层循环中，首先将两个人的分数从大到小排列，在头部加一个∞（得分的曲线只会在这些点改变），作为待选的杆数限制。然后对每一个限制，调整两人的得分，当调整前后两人的得分大小关系发生改变，说明两个人的排名发生了变化。遍历完其他人后，首先可以知道在无限制下的排名情况，再通过之前整理的排名变化情况，就可以得知在不同限制下的排名，从而得知最佳排名。
最后算法复杂度为O(N)。

#K Traffic Blights
##题目大意
终于到这题了，这题的解法相当厉害，是一道数论的题目。有一条直街，上面有一系列红绿灯，每个红绿灯都是红ri秒，绿gi秒这样无穷循环下去。现在有一些小车从街道最左按照均匀分布出现，每辆车速度都是1，最开始所有灯都同时变红，问第i盏灯是小车遇到的第一盏红灯，以及一路绿灯通过的概率是多少。
##解法
咋一看题目描述挺简单，通过暴力求解也不是不可以，但是题目的最优解法却非常牛批，想出来的人真他娘的是天才。
首先解释一些简单的情况。
设第i盏灯一个周期为pi=ri+gi，即是红一次绿一次的时间。

假设有两盏灯，由于这里都是整数，设它们的周期pi和pj互质，那么，小车在两盏灯各自绿灯通过的概率，就会是独立的。这里独立的意思是，小车通过后面的灯j的概率，不受它通过前面的灯i的概率的影响，也不受这两盏灯的位置和它们中间的距离的影响。既然是独立的，那么小车同时通过这两盏灯的概率，就可以简单地把单独通过两盏灯的概率乘起来就可以了。
这里解释一下他们为什么是独立的，假设小车是时间t从左边出发，有两盏灯，分别在l1,l2，小车要通过灯，需要t+l≡i(mod p)(i∈[r,p))，意思就是小车出发时间t加上行驶到灯处的时间l，除以周期p的余数，需要>=r且<p。
对于两盏灯，则需要求解方程组t1+l1≡i1(mod p1)(i1∈[r1,p1))和t2+l2≡i2(mod p2)(i2∈[r2,p2))
化简一下，就是t1≡i1(mod p1)(i1∈[(r1-l1)%p1,(p1-l1)%p1))
记r1'=(r1-l1)%p1,p1'=(p1-l1)%p1，对于p2也是一样的。现在即需要从[r1',p1')和[r2',p2')中任取两个数，构造一个剩余方程组
t1≡e1(mod p1)    e1∈[r1',p1')
t2≡e2(mod p2)    e2∈[r2',p2')
根据中国剩余定理，这个方程组总是有解的，因为有g1*g2个方程组，所以就有这么多解，即在两个灯的最小公倍数p1*p2的时间内，会有g1*g2个时间可以通过，所以同时通过两盏灯概率就等于单独通过的概率相乘，所以是独立的。

第二种情况，假设两盏灯周期相同，那通过两个灯的概率就不是独立的了，但他们都有周期p，这样只需要从前往后对每盏灯算一下周期p里面的p个时间，哪些能通过哪些不能就可以了，也很简单。如果有一盏灯的周期是另一盏的倍数，把短周期的灯也当成是长周期的就可以了。

以上两种情况都是比较简单的，真实的周期肯定不可能都是互质或者成倍数。但我们求解的时候可以先不用考虑在全体整数的时间，可以先只考虑整数的一个子集的时间。比如取一个整数T，只考虑集合{t ,t≡i(mod T)}  ,i∈[0,T)内的时间。在只考虑这些出发时间的情况下，每盏灯依然是周期变化的，只不过周期变成了pi/gcd(T,pi)，那么P(在灯i遇上红灯)=(i=0→T-1)ΣP(在{t ,t≡i(mod T)}内的时间在灯i遇上红灯)，即对每一个子集分别求概率，再加和就是全体时间遇上红灯的概率。这样的话，可以通过巧妙地选取一个T，令到所有的周期都互质或者成倍数。

由于所有灯的周期都<100，这里选了一个magic number T=2^3*3^2*5*7=2520。为什么选这个数呢，这个数是一个质数的幂，假设将周期因数分解成pi=P1^e1*P2^e2*...，这里P都是质数，e是整数。在<100的情况下，最多有2^4=64, 3^3=27, 5^2=25, 7^2=49，这几个质数数再多一次幂就会超过100，其他质数则2次幂都会超过100。这样对于任何pi'=pi/gcd(T,pi)，它只能是pi'=Pi*Pj*Pk...这样的质数的乘积，那么任何两个变更后的周期都会是互质或者成倍数的了。

有了以上的分析，就可以对2520的每一个余数求出到达每一盏灯是第一次红灯的概率，最后把它们加总就是总的概率了。
最后的时间复杂度是O(TNp)   T=2520,p<100

#写在最后，一点心得
因为之前没有过ACM相关的经验，做这个题一来是觉得ICPC World Final毕竟是同类里最高级的赛事了，二是想锻炼一下自己的编程能力。所以有些题做起来都是基本是现学现卖，这个过程其实还挺有意思的，有点想平时写业务代码的加强版，先理解好产品经理的需求是什么，然后用代码去实现，其实挺锻炼编程能力的。而且这些没在教材上出现过的算法一来不算难，花点时间就能学会，二来在某些特定领域也是有作用的，比如字符串处理相关的在文本匹配和搜索领域，做搜索引擎相关的事情，还有一些图论的应用。
同样我的代码写出来没有那么追求极致简洁，毕竟不是竞赛，不需要追求编码时间最短，更加偏向于可读可维护，当然也可能有疏漏的地方，欢迎互相学习指正。再来ICPC不愧为最顶级的赛事，19年的题目出的很好，很贴近实际，很有应用意义，相比以往在一些OJ上看到的题目，明显是为了套某个算法生搬硬套的，看着都不想去做去了解算法了。
另外，写这个题解的过程也是一种锻炼，之前写代码的时候，只求知道算法细节，不求甚解，没有去刨根问底的追问为什么这里要这么做，原理是什么，有什么好处。写这篇题解的时候，从头到尾理了一遍思路，也搞明白了之前没有了解的一些细节。就像读一些开源工程的源码，只能知道个大概的how，却没有彻底弄清楚why，弄清楚后面的这整一个过程，对水平的提升还是有很大帮助的。朋友们如果看完题解有什么问题，也欢迎直接留言，在评论区里面提问或者讨论。