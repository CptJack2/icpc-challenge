#ICPC World Final 2019 完全题解
19年的题目出的真的不错，但网上没有发现比较完整的题目解析，一般只能找到些AC的代码，但这些代码的可读性也不好。同时官方的解析和视频有些地方比较模糊甚至是错的，所以在写完了19年的所有题目后，打算写一篇2019年world final的完全的题解。
我做题的顺序是F -> A -> B -> H -> I -> J -> E -> D -> G -> C -> K -> G，刚好第一题就几乎是实现上最难的一题，反而第一题用的时间最久。

#A Azulejos
##题目大意
要将两排砖按照以下条件排列：1.前排的要严格矮于后排的。2.每一排的价格从左到右需要是越来越贵（可以相等）
##解法
贪心法即可，这题算是最简单的了。首先将两排砖分别按价格排序，价格相同的划到同一个set。然后都从最低价开始，拿出前排当前最低价的一块砖摆上，然后到后排的当前最低价的砖里面找一块刚好能满足要求的（刚好比前排的高1个单位，没有的话就是比这个高的最矮的），一直到摆完就可以了；要是这时候找不到这样的砖（就是最低价的都比前面的矮），那就知道没法摆了，直接输出impossible。
由于只需要遍历所有砖块一遍就可以解决，所以复杂度是O（N）的。

#B Beautiful Bridges
##题目大意
在一段崎岖的山路（分段的折线）上建拱桥，要求桥面是平的，桥的海拔高度也指定了。只能在折线的端点上建柱子，每两个柱子间要建圆拱。建柱子的单位费用是α，建圆拱的费用是β，求建桥耗费最少的价格。
##解法
用动态规划的方法求解，用数组dp[i]（i∈[0,n]，dp[i]初始化为∞）表示从0点到i点建桥的最少费用，令i：0→n，j:i+1→n，不断尝试在ij间建圆拱，如果相比前面的方案这个方案更优，就更新dp数组。最后dp[n]就是最小费用，如果是∞就是无解。
建圆拱时，需要先求从i点能够建造的圆拱的半径的最大值和最小值。设i点x坐标为0，圆拱的半径为R，hi是i处桥平面到山顶的高，首先有0<=R<=2*hi。
然后遍历后面的每一点j，设H是桥海拔高度，d为ij间水平距离，hj是j处桥平面到山顶的高。那么圆心坐标就是（R，H-R), j点坐标是（d,H-h)。对于每一个j点，都要保证桥拱能越过j点的山顶，即满足不等式(R-d)^2+(R-h)^2<=R^2(根据圆心到j点的距离为R，勾股定理列出方程。不等式通过一元二次方程的通解公式解。)。同时，对于j点建造的圆拱，同样有R<=2*hj，如果j点不能构造那么大的圆拱，那么i点的圆拱必须要跨过j点，因此圆拱半径必须大于使得j点刚好擦过圆拱右半边的半径。
这样不断遍历j点，收缩圆拱的可行半径，判断是否更优答案，就可以得到答案。根据上面的分析，整个求解复杂度为O(N)。

#C Checks Post Facto
##题目大意
有一种叫Checkers的棋类游戏，现在有一系列棋谱，要通过棋谱还原出原来的可能的局面。
规则如下：
棋子分为两种，小兵和大王，兵只能往前斜走，王能往回走，隔着对方的子跳过去能吃棋。兵到了对面底线能晋升王。
如果当前局面能吃子，必须先吃子。
##解法
题目算法不难，难处在于实现上有特别多细节需要注意。
首先需要正序遍历一遍棋谱，把棋谱上移动了的棋子但棋盘上没有的，给它摆上去。摆的时候，优先摆man（因为移动方向只有2个，后面检查jump优先的时候更方便），不符合规则才换成king。同时把jump中被吃掉的子也补上，并且处理吃子和晋升的情况。
下面是检查局面是否符合jump优先的规则，再次正序跑一遍棋谱，如果有不符合的情况，需要用一些从头到尾未被移动过的棋子去挡住这个可能jump的路线。由于不确定这个位置是放黑棋还是白棋，所以两种情况都要递归地试一下。
由于棋盘只有32个位置，问题规模较小，所以复杂度对时间的影响不大。

#D Circular DNA
##题目大意
有一个环形的DNA，有若干种类型的基因子，每种类型的基因子都只有s和e两类，类型写在下标，基因子长si或者ei这样的样子。现在在圈上顺便找一个位置剪一刀，得到一个线性序列。
现在，在这个线性序列中，如果一个下标类型i的基因子，都是s在前e在后，像括号一样对的上的话，那么这一个类型就是properly nested的
问你在环形DNA中哪里剪开，能使得最多的下标类型properly nested。
##解法
先从0号位开始剪开，对每一种下标类型维护一个counter，记录能够互相匹配的s减去e的数目，再记录一个没有被匹配上的e的数目。当一个类型properly nested，等价于它的counter的两个记录都为0。
然后可以按照逆时针或者顺时针的顺序调整切点，并更新counter，并更新properly nested的类型的数量，转完一圈后最大的就是答案了。
我是逆时针调整切点更新的，有一个简化的窍门，如果counter的两个记录不相等，那么这个类型的s和e数量一定是不匹配的，直接不统计了，具体可以看看代码。调整时，只需看看当前变更的这个基因子。逆时针调整，相当于把当前的队尾移动到队头，如果是s可能会匹配上之前没匹配的e，如果是e那一定是拆对了，把counter调整好就可以。
最后复杂度是O(N)的，很快。

#E Dead-End Detector
##题目大意
有一个街道的地图，是个无向图（也可以理解是双向车道）。如果你的车从某个点开出，不在某个地方来个180°掉头，是回不到这个点的，那么那个点的那一个出口，就要安一个此处是死路的标志。同时，为了省钱，一条有向的路径（经过若干个点）上，只在开头安装标志（其它地方应装的不装）。现在问你最少要装多少个标志，以及装在哪。
##解法
首先，图里面可能存在多个连通分量，先找出各个连通分量，单独处理。
然后，每个连通分量分为是树（度的和等于结点数减一）和不是树（度的和大于等于结点数）两种情况。
如果是树的话，只需要在每个叶子结点（度为1）处安装标志即可，因为树中任何一点都是一定要掉头才能回去的，而叶子结点之外的节点的每个路口，肯定可以从一个叶子结点作为起点到达，所以标志就省了。
如果不是树的话，那么不断把度为1的叶子结点删掉，更新他的去向结点的度，一直删到没有度为1的点为止。这样的删法到最后剩下的一定是一些环，被删掉的都是一些树根在环上的树上的结点（就像H题里面的那样），最后在环上通向树上的口放标志即可。因为树上的结点可以通过树根到环上转一圈再回来，是没有死路的；环上的结点到树上一定是死路，所以在树根放一个。
最后复杂度为O(N+E)，N是结点数，E是度，因为每个结点和连线都被遍历了常数次。

#F Directing Rainfall
这个单独写过一篇，翻一下就好了。

#G First of Her Name
#题目大意
有一个贵族，她们的名字是在祖先的名字前加一个字母。现在给一个这样的族谱，还有若干个字符串，问你以这个字符串作为前缀的女王有多少个。
题目很简明扼要，这个题有两种解法。
#解法一
首先每个女王只有一个祖先，根据输入构造出来的就是一颗字典树。首先对字典树用倍增算法找出他2^n次方的祖先。如果不了解倍增算法，可以网上搜一下，或者搜英文关键词binary lifting。同时这里采取构造后缀数组(suffix array)的类似的排序方法，不了解的同样可以搜一下，对字典树中的节点进行排序（每一个节点代表一个人名）。最后得出一个按字典序排序过的有序的数组，用二分查找就可以得出以某个字符串为前缀的女王有多少个了。
简单讲一下排序的具体方法，一开始先按第一个字母的字典序为每个节点赋予一个初始排序，只计算不同的字母（相当于sql里面的count distint）。然后，每次排序将参与排序的串长度翻倍（利用了字典树的性质，一个串总可以作为另一个串的后缀），排序的关键字就有了两个，第一关键字就是跟这个节点绑定的排名，第二关键字就是它倍增祖先节点绑定的排名（binary lifting在这里用到了）。两个关键字再次排好序后，这里的排序同样是count distinct的，更新节点绑定的排名。因为每个女王名字保证不同，所以排序总是有且唯一的。
最后算法复杂度binary lifting部分因为是DFS，所以是O(N)，排序部分因为要进行logN次O(NlogN)的快排，所以是O(N(logN)^2)。提一句，这里的排序方法如果不是快排，而是基数排序的话，理论可以达到O(NlogN)（logN次O(N)的基数排序），但我实际写的时候这样是超时的，可能我写的不对，附上了代码和火焰图，有兴趣的朋友可以研究研究。
还有另外一个比较坑的东西，查询的字符串中可能有重复的，这个注意一下就好。
#解法二
解法二相当有意思，用到了AC自动机（Aho-Corasick Automaton）和与AC自动机相关的fail树，需要先自行了解这个算法。
首先需要把女王名字反转过来，加到前面的就变成了加到后面，查询前缀变成查询后缀，还是建出字典树。然后把查询的字符串也加入到字典树里面。然后在字典树上面建立AC自动机，由于字典集是{A-Z}的有限集，每个节点添加遇到每一个字符的快速跳转表，建立好failure link，同时建好fail树。简单讲一下fail树，由于每个节点只有一个failure的出链接，最后都会一直汇聚到树根，这样就变成一个fail树。最后求答案的时候，为字典树中每个节点赋初值0，对代表女王名字的节点赋值1，最后通过一次dfs，父节点的值取所有子节点的值的和。dfs完后，代表查询字符串的点上的值就是答案。
这里利用的就是沿着failure链接转移，下家是上家的最长后缀，的性质。由于普通的AC自动机只能统计某个词有没有出现过，要统计词频需要不断沿着failure转移，对同样后缀的词也进行统计，这样就会耗时更多，在这里某个测试用例会超时；利用fail树的结构做一次dfs就可以直接知道词频了，上限是O(N)。
整个算法的复杂度是O(N)。

#H Hobson's Train
单独有过一篇题解。

#I Karel the Robot
单独有过一篇题解。

#J Mininature Golf
##题目大意
p个人一起打高尔夫，一共有h局，每局每人一个杆数。打完之后，他们想为杆数设一个最大值调整得分，如果那一局杆数超过最大值就把杆数改成最大值。问在不同的杆数最大值下，每个人的最高排名分别是多少。
##解法
对于每个人的总杆数，关于杆数限制的函数，是一个分段线性函数。如图所示。当限制超过他的最大杆数，直线是平的，前面的线段的斜率，就是这个人有多少杆的得分超过了这一个限制。
![img.png](img.png)
首先将每个人自己的分数进行一个从大到小的排序。用两重循求出每个人的最佳排名，外层循环每次处理一个人；内层循环遍历其他所有人。内层循环中，首先将两个人的分数从大到小排列，在头部加一个∞（得分的曲线只会在这些点改变），作为待选的杆数限制。然后对每一个限制，调整两人的得分，当调整前后两人的得分大小关系发生改变，说明两个人的排名发生了变化。遍历完其他人后，首先可以知道在无限制下的排名情况，再通过之前整理的排名变化情况，就可以得知在不同限制下的排名，从而得知最佳排名。
最后算法复杂度为O(N)。